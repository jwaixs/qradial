from que import Monomial, Polynomial

print('=== Start q-cm.sage ===')

q = var('q')

E1 = Monomial(1, ['E1'])
E2 = Monomial(1, ['E2'])
F1 = Monomial(1, ['F1'])
F2 = Monomial(1, ['F2'])
K1 = Monomial(1, ['K1'])
K2 = Monomial(1, ['K2'])
K1inv = Monomial(1, ['K1'], [-1])
K2inv = Monomial(1, ['K2'], [-1])

c1, c2, d1, d2 = var('c1 c2 d1 d2')

l = var('l')

# B1c = F1 - c1 * E2*K1inv
# B2c = F2 - c2 * E1*K2inv
# B1d = F1 - d1 * E2*K1inv
# B2d = F2 - d2 * E1*K2inv

# right coideal generators
K = Monomial(1, ['K'])
B1c = Monomial(1, ['B1c'])
B2c = Monomial(1, ['B2c'])
B1d = Monomial(1, ['B1d'])
B2d = Monomial(1, ['B2d'])

A = Monomial(1, ['A'])

Al = Monomial(1, ['A'], [l])

def step1(Fk):
    '''Convert Fk to El and Bl, returns Bl, scalar, El'''
    if Fk.monomial[0] == 'F1':
        return B1d, d1, E2*K1inv
    else:
        return B2d, d2, E1*K2inv

def step2a(FI, Ek):
    if len(FI.monomial) == 0:
        return 1, 0

    F_last = FI[-1]
    F_rest = FI[:-1]

    if Ek.monomial[0] == 'E1':
        Eind = 1
    else:
        Eind = 2

    if F_last.monomial[0] == 'F1':
        Find = 1
    else:
        Find = 2

    if Find == 1 and Eind == 1:
        s, r = step2a(F_rest, Ek)
        if len(F_rest.monomial) > 0:
            rest = 1 / (q - q**(-1)) * F_rest * A**(-1) \
                - 1 / (q - q**(-1)) * F_rest *  K
        else:
            rest = 1 / (q - q**(-1)) * A**(-1) - 1 / (q - q**(-1)) * K
        if r != 0:
            return q*s, q*r + rest
        else:
            return q*s, rest
    elif Find == 1 and Eind == 2:
        s, r = step2a(F_rest, Ek)
        return q**(-2)*s, q**(-2)*r*F1
    elif Find == 2 and Eind == 1:
        s, r = step2a(F_rest, Ek)
        return q**(-2)*s, q**(-2)*r*F2
    elif Find == 2 and Eind == 2:
        s, r = step2a(F_rest, Ek)
        if len(F_rest.monomial) > 0:
            rest = 1 / (q - q**(-1)) * F_rest * (A**(-1) - K**(-1))
        else:
            rest = 1 / (q - q**(-1)) * (A**(-1) - K**(-1))
        if r != 0:
            return q*s, q*r + rest
        else:
            return q*s, rest

def step2b(torus):
    # Commutation relation A^l between E_i K_i^{-1}
    return q**(torus.power[0])

def step3(Ek):
    if Ek.monomial[0] == 'E1':
        return 1/c2, F2, -1/c2 * B2c
    elif Ek.monomial[0] == 'E2':
        return 1/c1, F1, -1/c1 * B1c

def step4(torus):
    return q**(torus.power[0])

def convert(torus, F_seq):
    '''Apply one step of the q-radial algorithm, i.e. it maps

        A^l F_1 F_2 ... F_k |--> q^x A^l F_k F_1 ... F_{k-1} + ...

    Inputs:
        torus - Torus element A^l.
        F_seq - Monomial sequence F_1 F_2 ... F_k.

    Returns:
        scalar - Scalar term of A^l F_k F_1 ... F_{k-1}.
        main_mon - Monomial sequence A^l F_k F_1 ... F_{k-1}
        rest - Polynomial of extra terms generated by the algorithm.
    '''
    F_stable = F_seq[0:-1]
    F_last = F_seq[-1]

    # Step one, F_last to B and E
    s1_B, s1_scalar, s1_Ek = step1(F_last)

    # Step two a, commute between F_stable and E
    s2a_scalar, s2a_rest = step2a(F_stable, s1_Ek)

    # Step two b, commute EK and A^l
    s2b_scalar = step2b(torus)

    # Step three, replace EK with F - B
    s3_scalar, s3_F, s3_rest = step3(s1_Ek)

    # Step four, commute F and A^l
    s4_scalar = step4(torus)

    main_scalar = s1_scalar * s2a_scalar * s2b_scalar * s3_scalar * s4_scalar
    main_term = Al * s3_F * F_stable

    rest = torus * F_stable * s1_B
    if s2a_rest != 0:
        rest += s1_scalar * torus * s2a_rest
    if s2b_scalar != 0 and s3_rest != 0:
        rest += s1_scalar * s2a_scalar * s2b_scalar * s3_rest * torus * F_stable

    return main_scalar, main_term, rest

def std_form_A(M):
    scalar = M.scalar
    power = M.power
    monomial = M.monomial

    for i in range(len(monomial)-1, 0, -1):
        t1 = monomial[i]
        p1 = power[i]

        t2 = monomial[i-1]
        p2 = power[i-1]

        if t1 == 'A':
            if t2[0] == 'F':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(p1*p2)
            elif t2[0] == 'E':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(-p1*p2)
            elif t2 == 'A':
                power[i-1] += p1
                del power[i]
                del monomial[i]

    return Monomial(scalar, monomial, power)

def std_form_K(M):
    scalar = M.scalar
    power = M.power
    monomial = M.monomial

    for i in range(len(monomial)-1, 0, -1):
        t1 = monomial[i]
        p1 = power[i]

        t2 = monomial[i-1]
        p2 = power[i-1]

        if t1 == 'K':
            if t2 == 'F1':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(p1*p2)
            elif t2 == 'F2':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(-p1*p2)
            elif t2 == 'E1':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(-p1*p2)
            elif t2 == 'E2':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

                scalar *= q**(p1*p2)
            elif t2 == 'A':
                monomial[i] = t2
                power[i] = p2

                monomial[i-1] = t1
                power[i-1] = p1

            elif t2 == 'K':
                power[i-1] += p1
                del power[i]
                del monomial[i]

    return Monomial(scalar, monomial, power)

def split_monomial(m):
    # Split monomial in B, A, FI, B parts
    scalar = m.scalar
    try:
        a_index = m.monomial.index('A')
    except ValueError:
        return None

    # No FI part
    if a_index == len(m.monomial) - 1:
        return None

    if m.monomial[a_index+1][0] != 'F':
        return None

    f_start = a_index + 1
    f_stop = f_start
    while f_stop <= len(m.monomial) - 1 and m.monomial[f_stop][0] == 'F':
        f_stop += 1

    left_B_part = None
    if a_index > 0:
        left_B_part = m[:a_index]

    torus = m[a_index]

    FI = m[f_start:f_stop]

    right_B_part = None
    if f_stop < len(m.monomial):
        right_B_part = m[f_stop:]

    return scalar, left_B_part, torus, FI, right_B_part

def bab_decomposition(torus, F_seq):
    if len(F_seq.monomial) == 0:
        return torus

    start_seq = F_seq.monomial

    # Apply convert step until first occurence of same sequence.
    scalar, main, rest = convert(torus, F_seq)
    new_seq = main[1:]
    while new_seq.monomial != F_seq.monomial:
        ns, main, nr = convert(torus, new_seq)
        new_seq = main[1:]
        rest += scalar * nr
        scalar *= ns

    # Bring rest term into standard form
    std_rest = None

    for m in rest.flatten():
        std_m = std_form_A(std_form_K(m))
        if std_rest == None:
            std_rest = std_m
        else:
            std_rest += std_m

    # Apply bab decomposition to lower rest terms
    bab_rest = None

    for m in std_rest.flatten():
        split = split_monomial(m)
        if split == None:
            if bab_rest == None:
                bab_rest = m
            else:
                bab_rest += m
        else:
            s, left_B, torus, FI, right_B = split
            m_bab = s * bab_decomposition(torus, FI)

            if left_B != None:
                m_bab = left_B * m_bab
            if right_B != None:
                m_bab = m_bab * right_B

            if bab_rest == None:
                bab_rest = m_bab
            else:
                bab_rest += m_bab

    return 1 / (1 - scalar) * bab_rest.flatten()

def compare(a, b):
    if type(a) == Polynomial and type(b) == Polynomial:
        for m1 in a:
            equal = False
            for m2 in b:
                if compare(m1, m2):
                    equal = True
                    continue
            if not equal:
                return False
        return True
    elif type(a) == Monomial and type(b) == Monomial:
        if a.monomial == b.monomial and a.power == b.power \
                and a.scalar == b.scalar:
            return True
        else:
            return False
    else:
        return False
